import { is, Column, SQL, getTableName, fillPlaceholders, entityKind, NoopLogger, DefaultLogger, extractTablesRelationalConfig, createTableRelationsHelpers } from 'drizzle-orm';
import { PreparedQuery, PgSession, PgDialect, PgDatabase, text, pgTable, date, decimal, integer, boolean } from 'drizzle-orm/pg-core';

function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
const exhaustiveCheck = (x) => {
  throw new Error(`Unhandled discriminated union member: ${x}`);
};

var _a, _b;
class XataPreparedQuery extends PreparedQuery {
  constructor(client, queryString, params, logger, fields, name, customResultMapper) {
    super();
    this.client = client;
    this.params = params;
    this.logger = logger;
    this.fields = fields;
    this.customResultMapper = customResultMapper;
    this.query = {
      name,
      statement: queryString
    };
  }
  async execute(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.query.statement, params);
    const { records = [], warning } = await this.client.sql({
      statement: this.query.statement,
      params
    });
    const fields = this.fields ?? Object.keys(records[0]).map(
      (key) => ({
        path: [key],
        field: {
          sql: {
            decoder: {
              mapFromDriverValue: (value) => value
            }
          }
        }
      })
    );
    if (warning)
      console.warn(warning);
    const internalColumnNames = ["xata.version", "xata.createdAt", "xata.updatedAt", "xata.deletedAt"];
    const rows = records.map(
      (record) => fields.map((field) => {
        const pathAsString = field.path.join(".");
        if (internalColumnNames.includes(pathAsString)) {
          const [namespaceXata, namespaceColumn] = pathAsString.split(".");
          return record[namespaceXata][namespaceColumn];
        }
        return record[pathAsString];
      })
    );
    if (this.customResultMapper) {
      return this.customResultMapper(rows);
    }
    return rows.map((row) => mapResultRow(fields, row, void 0));
  }
  async all(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.query.statement, params);
    const { records } = await this.client.sql({
      statement: this.query.statement,
      params
    });
    return records;
  }
  async values(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.query.statement, params);
    const { records } = await this.client.sql({
      statement: this.query.statement,
      params
    });
    return records;
  }
}
_a = entityKind;
XataPreparedQuery[_a] = "VercelPgPreparedQuery";
class XataSession extends PgSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger();
  }
  prepareQuery(query, fields, name, customResultMapper) {
    return new XataPreparedQuery(this.client, query.sql, query.params, this.logger, fields, name, customResultMapper);
  }
  async query(query, params) {
    this.logger.logQuery(query, params);
    return await this.client.sql({ statement: query, params });
  }
  async queryObjects(query, params) {
    return this.client.sql({ statement: query, params });
  }
  async transaction(_transaction, _config) {
    throw new Error("Transactions are not supported");
  }
}
_b = entityKind;
XataSession[_b] = "VercelPgSession";

function drizzle(client, config = {}) {
  const dialect = new PgDialect();
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger();
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new XataSession(client, dialect, schema, { logger });
  return new PgDatabase(dialect, session, schema);
}

function buildColumnType(column) {
  switch (column.type) {
    case "string":
    case "text":
    case "email":
    case "link":
      return text(column.name);
    case "bool":
      return boolean(column.name);
    case "int":
      return integer(column.name);
    case "float":
      return decimal(column.name);
    case "datetime":
      return date(column.name);
    case "multiple":
    case "object":
    case "vector":
    case "file[]":
    case "file":
    case "json":
      throw new Error(`Unsupported column type: ${column.type}`);
    default:
      return exhaustiveCheck(column.type);
  }
}
function buildColumn(column) {
  let type = buildColumnType(column);
  if (column.notNull) {
    type = type.notNull();
  }
  if (column.unique) {
    type = type.unique();
  }
  return type;
}
function buildTable(schema) {
  const columns = schema.columns.map((column) => [column.name, buildColumn(column)]);
  const definition = { id: text("id"), ...Object.fromEntries(columns) };
  return pgTable(schema.name, definition);
}
function buildModels(tables) {
  const entries = tables.map((table) => [table.name, buildTable(table)]);
  return Object.fromEntries(entries);
}

export { XataPreparedQuery, XataSession, buildModels, drizzle };
//# sourceMappingURL=index.mjs.map
